请问各位大佬 为什么Fiat–Shamir heuristic里面给verifier发的证明函数需要 mod p-1? 我知道p-1是Euler's totient 但是不太理解为什么要这么做

zk可以做到唯一性证明吗，比如我有52张扑克，给几个人发牌，怎么做到既不知道别人什么牌，又不会把已经发过的牌再发一遍

什么时候需要公开的输入？

## tau和p的关系


## 三元运算

Claudable:
第一个，inv非零即一，那你看一下你的约束，等价于你让输入跟零或一建立约束。相当于你定义，一个数等于零即这个数乘以一要等于零，一个数不等于零即这个数乘以零要等于零。这里面的漏洞自然就是零乘以零也等于零。所以会被攻击。

Claudable:
而正确的判断一个数是否为零应该是，一个数等于零即这个数乘以负一再加一等于一，一个数不等于零即能够找到一个数为这个数的倒数，使得他们乘积的负数再加一等于零。

Claudable:
如果你想说第一个情况里，如果输入是零，那么inv＝1，不存在0*0的情况。那就需要再理解一下预计算的提示与约束的区别。只有约束会被证明。如果你还想不通，你可以把inv转成signal input，人也提供代替它帮你计算，本质上约束不变，电路就等价。然后你尝试攻击一下这俩电路，就知道区别了。

Claudable:
人为提供，打错了

李明:
这种语法设计确实很容易让人困惑，虽然设计的初衷是为了简化，预计算和约束应该有更加明显的区别

lansane:
第一种写法没有约束来说明不能出现0*0的情况

Claudable:
我个人觉得不需要刻意思考区别。你只需要时刻保证证明的完备性。你可以随意给一个hint，但必须要有足够的约束来保证这个hint的值是正确的，而不是也没办法保证hint的计算过程是正确的。我们只关心它的值。

Claudable:
我觉得circom的电路写法有两种，一种是求解式，就像解方程组一样，一步一步带约束直到结果。一种是验证式，就是我们直接给定结果，反向约束是结果是正确的。

Claudable:
再直观点，冒泡排序，除了课上的解题思路，还有一种，你先用常规代码不带约束地排出结果，然后给这个结果上约束，它必须是一个原数组的重新排列组合。而且它符合排序要求，单调递增或递减。

## 大佬们，这里是不是不能出现小数

皮卡逐步逼近皮卡丘:
我记得是电路约束里不能有除法

0x13600702:
约束里不能有

0x13600702:
但是计算里可以有，如果算出来是小数，咋整，是直接舍去小数部分嘛

皮卡逐步逼近皮卡丘:
我不知道了诶 按理说是在有限域上进行验证的，应该是整数

0x13600702:
对，刚问了下chatgpt，不能是小数

皮卡逐步逼近皮卡丘:
哈哈 chatgpt厉害

Walker:
除法就是乘逆元，逆元是个整数

Li Cong:
[图片]

Li Cong:
这个是为什么?

Li Cong:
为什么实现电路约束首先要自己实现bigint的操作?

Daniel_譚:
BigInt arithmetic就是在很大的prime field操作吧

Daniel_譚:
不然你每写一步都要mod p

Claudable:
很多情况下你的电路应用场景中有数比证明系统使用的曲线定义的有限域还要大，比如他说的bn254上模拟256位数的运算。就是有限域~2\*\*254，而你的应用里存在2\*\*256的数，比如32bytes的hash，那就要用254内的数去 模拟256位数的基本运算。
